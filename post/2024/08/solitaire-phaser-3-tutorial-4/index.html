<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Solitaire HTML5 Game Tutorial With Phaser 3 Part 4: Moving Cards - Scott Westover</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Solitaire HTML5 Game Tutorial With Phaser 3 Part 4: Moving Cards"><meta property="og:description" content="In this tutorial series, we’ll be looking at how to recreate the game Solitaire using the Phaser 3 framework. Here’s an example of what the final game should look like:
Previously, in part 3 , we focused on adding support for player input by listening for click and drag events in our game.
In part 4 of this series, we are going to start working on adding support for moving cards between the various card piles in our game."><meta property="og:type" content="article"><meta property="og:url" content="https://scottwestover.dev/post/2024/08/solitaire-phaser-3-tutorial-4/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-08-29T08:00:02+00:00"><meta property="article:modified_time" content="2024-08-29T08:00:02+00:00"><meta itemprop=name content="Solitaire HTML5 Game Tutorial With Phaser 3 Part 4: Moving Cards"><meta itemprop=description content="In this tutorial series, we’ll be looking at how to recreate the game Solitaire using the Phaser 3 framework. Here’s an example of what the final game should look like:
Previously, in part 3 , we focused on adding support for player input by listening for click and drag events in our game.
In part 4 of this series, we are going to start working on adding support for moving cards between the various card piles in our game."><meta itemprop=datePublished content="2024-08-29T08:00:02+00:00"><meta itemprop=dateModified content="2024-08-29T08:00:02+00:00"><meta itemprop=wordCount content="3751"><meta itemprop=keywords content="HTML5,Game Development,TypeScript,Tutorial,Solitaire,PhaserJS,Phaser3,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Solitaire HTML5 Game Tutorial With Phaser 3 Part 4: Moving Cards"><meta name=twitter:description content="In this tutorial series, we’ll be looking at how to recreate the game Solitaire using the Phaser 3 framework. Here’s an example of what the final game should look like:
Previously, in part 3 , we focused on adding support for player input by listening for click and drag events in our game.
In part 4 of this series, we are going to start working on adding support for moving cards between the various card piles in our game."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Scott Westover" rel=home><div class="logo__item logo__text"><div class=logo__title>Scott Westover</div><div class=logo__tagline>A Developer's Blog</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/courses/><span class=menu__text>Courses</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>About Me</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Solitaire HTML5 Game Tutorial With Phaser 3 Part 4: Moving Cards</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2024-08-29T08:00:02Z>August 29, 2024</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/html5/ rel=category>HTML5</a>, <a class=meta__link href=/categories/game-development/ rel=category>Game Development</a>, <a class=meta__link href=/categories/typescript/ rel=category>TypeScript</a>, <a class=meta__link href=/categories/tutorial/ rel=category>Tutorial</a>, <a class=meta__link href=/categories/solitaire/ rel=category>Solitaire</a>, <a class=meta__link href=/categories/phaserjs/ rel=category>PhaserJS</a>, <a class=meta__link href=/categories/phaser3/ rel=category>Phaser3</a></span></div></div></header><figure class="post__thumbnail thumbnail"><img class=thumbnail__image src=/post/2024/08/solitaire-phaser-3-tutorial-4/images/solitaire-phaser-3-tutorial-4-thumbnail.png alt="Solitaire HTML5 Game Tutorial With Phaser 3 Part 4: Moving Cards"></figure><div class="content post__content clearfix"><p>In this tutorial series, we’ll be looking at how to recreate the game Solitaire using the Phaser 3 framework. Here’s an example of what the final game should look like:</p><img src=/img/phaser-3-solitaire-tutorial/gameplay.gif alt="Phaser Solitaire Gameplay" style=margin-bottom:10px><p>Previously, in
<a href=/post/2024/08/solitaire-phaser-3-tutorial-3/>part 3</a>
, we focused on adding support for player input by listening for click and drag events in our game.</p><p>In part 4 of this series, we are going to start working on adding support for moving cards between the various card piles in our game.</p><p>With our basic input handling implemented, the next thing we are going to do is start to add support for moving cards between our various piles in our game, and this will include:</p><ul><li>moving cards from the discard pile to tableau piles</li><li>moving cards from the discard pile to the foundation piles</li><li>moving cards from one tableau pile to another</li><li>moving cards from the tableau pile to the foundation piles</li></ul><p>In order to add this functionality, we will be adding in new Zone game objects, which we will be using for detecting where a card was dropped in our game.</p><h2 id=adding-drop-zones>Adding Drop Zones</h2><p>Previously, we added a Zone game object to our draw card pile to allow us to have 1 game object that we can check for click events when we need to draw a card. Not only can Zone game objects be used for detecting click events, we can also use those game objects to see if another game object was dropped on the Zone game object. To do this, we can use the built in helper methods to create a drop zone area and then listen for the <code>drop</code> event. To do this, lets go ahead and add the following code to the bottom of the <code>create</code> method in the <code>GameScene</code> class in the <code>src/scenes/game-scene.ts</code> file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>createDropZones</span>();
</span></span></code></pre></div><p>and then add the following code to the <code>GameScene</code> class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>createDropZones</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// create drop zone for foundation piles, in the game we will have 1 drop zone and then automatically place the card in the pile it belongs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// for each drop zone, we add custom data so when the `drag` event listener is invoked, we can run specific logic to that zone type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>zone</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>add</span>.<span style=color:#a6e22e>zone</span>(<span style=color:#ae81ff>350</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>270</span>, <span style=color:#ae81ff>85</span>).<span style=color:#a6e22e>setOrigin</span>(<span style=color:#ae81ff>0</span>).<span style=color:#a6e22e>setRectangleDropZone</span>(<span style=color:#ae81ff>270</span>, <span style=color:#ae81ff>85</span>).<span style=color:#a6e22e>setData</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>zoneType</span>: <span style=color:#66d9ef>ZONE_TYPE.FOUNDATION</span>,
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>DEBUG</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>add</span>.<span style=color:#a6e22e>rectangle</span>(<span style=color:#ae81ff>350</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>zone</span>.<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>zone</span>.<span style=color:#a6e22e>height</span>, <span style=color:#ae81ff>0xff0000</span>, <span style=color:#ae81ff>0.2</span>).<span style=color:#a6e22e>setOrigin</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// drop zone for each tableau pile in the game (the 7 main piles)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>7</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>zone</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>add</span>
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>zone</span>(<span style=color:#ae81ff>30</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>85</span>, <span style=color:#ae81ff>92</span>, <span style=color:#ae81ff>75.5</span>, <span style=color:#ae81ff>585</span>)
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>setOrigin</span>(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>setRectangleDropZone</span>(<span style=color:#ae81ff>75.5</span>, <span style=color:#ae81ff>585</span>)
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>setData</span>({
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>zoneType</span>: <span style=color:#66d9ef>ZONE_TYPE.TABLEAU</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>tableauIndex</span>: <span style=color:#66d9ef>i</span>,
</span></span><span style=display:flex><span>      })
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>setDepth</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>DEBUG</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>add</span>.<span style=color:#a6e22e>rectangle</span>(<span style=color:#ae81ff>30</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>85</span>, <span style=color:#ae81ff>92</span>, <span style=color:#a6e22e>zone</span>.<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>zone</span>.<span style=color:#a6e22e>height</span>, <span style=color:#ae81ff>0xff0000</span>, <span style=color:#ae81ff>0.5</span>).<span style=color:#a6e22e>setOrigin</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, add the following code to the top of the file with the other variables:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ZoneType</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>keyof</span> <span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>ZONE_TYPE</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// the different type of drop zones, or areas players can drop cards in the game
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ZONE_TYPE</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>FOUNDATION</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;FOUNDATION&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>TABLEAU</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;TABLEAU&#39;</span>,
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>const</span>;
</span></span></code></pre></div><p>In the code above, we did the following:</p><ul><li>First, we created a new variable called <code>ZONE_TYPE</code>, and we created a TypeScript type to represent this <code>type</code> as well. This new variable is used when we create our new drop zones, and we store this in the data manager on the Zone game objects. This will be used when we listen for the <code>drop</code> event, so that way we know which type of drop zone the player dropped the card on.</li><li>Next, we created 8 new Zone game objects in the <code>#createDropZones</code> method, 1 Zone for the foundation piles and 7 for each of the Tableau piles. In our game, we will just have the 1 drop zone for the foundation piles and we will have logic to automatically place the card on the correct pile.</li><li>When we created each Zone game object, we called a new method called <code>setRectangleDropZone</code>. When we call this method, we need to specify the size of the Rectangle shape that we would like to create for the Drop Zone, and in our code we are using the same size as the Zone game object. When we call this method, this will setup the Zone game object to be enabled for <code>drop</code> input, which will allow us to listen for <code>drop</code> events. For the time being, we are not doing this and will add this code next.</li><li>Finally, on each Zone game object we are storing some data in the data manager. The first is the <code>zoneType</code>, which is how we will know which type of Zone the card game object was added to, and then we set the <code>tableauIndex</code>, which will also be used to know which card pile the player was trying to add a card to. We also set the <code>depth</code> of each of our drop zones to be <code>-1</code>, that way they will be under all of the other game objects we create in our Scene. This is important since if they are placed on top of our other game objects, this can block some of the events from being triggered on those game objects.</li></ul><p>If you save your code changes and view the changes in the browser, you should now see 8 new red rectangles that represent the various drop zones in our game.</p><p><img src=./images/solitaire-phaser-3-tutorial-4-1.png alt="Drop zones"></p><p>With the new drop zones created, we now need to listen for events on these game objects. To do this, we need to register a new event listener, so in the <code>#createDragEvents</code> method, add the following code to the bottom of the method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>createDropEventListener</span>();
</span></span></code></pre></div><p>Next, add the following code to the <code>GameScene</code> class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>createDropEventListener</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// listen for drop events on a game object, this will be used for knowing which card pile a player is trying to add a card game object to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// which will then trigger validation logic to check if a valid move was maded
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>input</span>.<span style=color:#a6e22e>on</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Phaser</span>.<span style=color:#a6e22e>Input</span>.<span style=color:#a6e22e>Events</span>.<span style=color:#a6e22e>DROP</span>,
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>pointer</span>: <span style=color:#66d9ef>Phaser.Input.Pointer</span>, <span style=color:#a6e22e>gameObject</span>: <span style=color:#66d9ef>Phaser.GameObjects.Image</span>, <span style=color:#a6e22e>dropZone</span>: <span style=color:#66d9ef>Phaser.GameObjects.Zone</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>zoneType</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>dropZone</span>.<span style=color:#a6e22e>getData</span>(<span style=color:#e6db74>&#39;zoneType&#39;</span>) <span style=color:#66d9ef>as</span> <span style=color:#a6e22e>ZoneType</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>zoneType</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>ZONE_TYPE</span>.<span style=color:#a6e22e>FOUNDATION</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>handleMoveCardToFoundation</span>(<span style=color:#a6e22e>gameObject</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tableauIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>dropZone</span>.<span style=color:#a6e22e>getData</span>(<span style=color:#e6db74>&#39;tableauIndex&#39;</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>handleMoveCardTableau</span>(<span style=color:#a6e22e>gameObject</span>, <span style=color:#a6e22e>tableauIndex</span>);
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>handleMoveCardToFoundation</span>(<span style=color:#a6e22e>gameObject</span>: <span style=color:#66d9ef>Phaser.GameObjects.Image</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;placed card on foundation&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>handleMoveCardTableau</span>(<span style=color:#a6e22e>gameObject</span>: <span style=color:#66d9ef>Phaser.GameObjects.Image</span>, <span style=color:#a6e22e>targetTableauPileIndex</span>: <span style=color:#66d9ef>number</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;placed card on tableau pile&#39;</span>, <span style=color:#a6e22e>targetTableauPileIndex</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the code above, we created a new private method <code>#createDropEventListener</code>, which is were we register a new event listener on the Phaser Scene Input Plugin Manager for the <code>drop</code> event. This event listener will be triggered any time a game object is dropped onto one of our drop zones. When this event listener is triggered, we will receive details regarding pointer, the game object that was dropped, and the drop zone the game object was dropped onto. As we process the event, we first check to see what <code>zoneType</code> the card game object was dropped onto, and then call a new method associated with that card pile type, and for now we just log a message so we can test.</p><p>Now, back in your browser if you try to drag the various card game objects around and drop them on the various drop zones, you should see a message appear in the developer console with details of were the card was dropped.</p><p><img src=./images/solitaire-phaser-3-tutorial-4-2.gif alt="Listen for drop event"></p><h2 id=placing-cards>Placing Cards</h2><p>With the new drop zone game objects in place, the next thing we will do is work on adding logic to validate and leave cards in the new locations if a valid move was made. For the time being, part of this logic will be hard coded, but we will have the structure in place for when we have our actual Solitaire game logic. To get started, we will focus on playing cards from the discard pile to the tableau and foundation card piles. When a card from the discard pile is placed onto the foundation pile, or tableau piles, if the move is not valid we will want the card to be placed back on top of the discard pile. If the move is valid, we will need to add that card to the correct pile, and then update the cards displayed in the discard pile.</p><p>To get started with this logic, the first thing we will do is create a new class to represent the core Solitaire game logic. By creating the class now, we can define the interface for how we will interact with this class, and hard card values that will be returned. This will allow us to create the logic we need in our <code>GameScene</code> class and come back to this new <code>Solitaire</code> class later to add the actual logic. In this new class, we will have methods that will be called for validating each of our possible move types. These methods will be responsible for returning a <code>boolean</code> value to indicate if a valid move was made.</p><p>To do this, we will create a new folder under the <code>src</code> folder called <code>lib</code>, and in this new folder create a new file called <code>solitaire.ts</code>. Next, in the <code>src/lib/solitaire.ts</code> file, add the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solitaire</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>newGame</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>drawCard</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>boolean</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>shuffleDiscardPile</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>boolean</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>playDiscardPileCardToFoundation</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>boolean</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>playDiscardPileCardToTableau</span>(<span style=color:#a6e22e>targetTableauIndex</span>: <span style=color:#66d9ef>number</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>boolean</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>flipTopTableauCard</span>(<span style=color:#a6e22e>tableauIndex</span>: <span style=color:#66d9ef>number</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>boolean</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>moveTableauCardsToAnotherTableau</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>initialTableauIndex</span>: <span style=color:#66d9ef>number</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cardIndex</span>: <span style=color:#66d9ef>number</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>targetTableauIndex</span>: <span style=color:#66d9ef>number</span>,
</span></span><span style=display:flex><span>  )<span style=color:#f92672>:</span> <span style=color:#66d9ef>boolean</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>moveTableauCardToFoundation</span>(<span style=color:#a6e22e>tableauIndex</span>: <span style=color:#66d9ef>number</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>boolean</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the code above, we have defined the methods that we will call from <code>GameScene</code> class, when one of the card game objects are dropped into drop zone, and for the time being, each of these methods will return <code>true</code>. We also added the other <code>public</code> methods that will be called, but for the time being we can ignore these. Next, we will need to create an instance of our new class in our <code>GameScene</code> class. To do this, we will need to add the following code at the top of the file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Solitaire</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;../lib/solitaire&#39;</span>;
</span></span></code></pre></div><p>Then, at the top of the <code>GameScene</code> class, we will need to create a new private property, which will be an instance of our <code>Solitaire</code> class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// contains the core Solitaire game logic and has the actual game state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>solitaire</span><span style=color:#f92672>!:</span> <span style=color:#a6e22e>Solitaire</span>;
</span></span></code></pre></div><p>Finally, we need to create an instance of our class at the top of our <code>create</code> method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// create solitaire game instance
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>solitaire</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Solitaire</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>solitaire</span>.<span style=color:#a6e22e>newGame</span>();
</span></span></code></pre></div><p>So now that we have our new <code>Solitaire</code> instance, we will start working on adding in the logic to handle when a player drops cards from the discard pile onto the foundation piles. In the <code>#handleMoveCardToFoundation</code> method, we will need to check to see if the card that was dropped came from the discard pile, or from a tableau pile. To do this, we will check the data manager on the game object to see if the <code>pileIndex</code> field is set, and if so, then we know the card came from a tableau card pile. To do this, update the logic in the <code>#handleMoveCardToFoundation</code> method to be:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>isValidMove</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>isCardFromDiscardPile</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// check if card is from discard pile or tableau pile based on the pileIndex in the data manager
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tableauPileIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>gameObject</span>.<span style=color:#a6e22e>getData</span>(<span style=color:#e6db74>&#39;pileIndex&#39;</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>undefined</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>tableauPileIndex</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>undefined</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>isValidMove</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>solitaire</span>.<span style=color:#a6e22e>playDiscardPileCardToFoundation</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>isCardFromDiscardPile</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>isValidMove</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>solitaire</span>.<span style=color:#a6e22e>moveTableauCardToFoundation</span>(<span style=color:#a6e22e>tableauPileIndex</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// if this is not a valid move, we don&#39;t need to update anything on the card since the `dragend` event handler will
</span></span></span><span style=display:flex><span><span style=color:#75715e>// move the card back to the original location
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>isValidMove</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// update discard pile cards, or flip over tableau cards if needed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>isCardFromDiscardPile</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>updateCardGameObjectsInDiscardPile</span>();
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>handleRevealingNewTableauCards</span>(<span style=color:#a6e22e>tableauPileIndex</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// only destroy card from tableau, since we need to reuse the card from the discard pile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>isCardFromDiscardPile</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>gameObject</span>.<span style=color:#a6e22e>destroy</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// update our phaser game objects
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>updateFoundationPiles</span>();
</span></span></code></pre></div><p>Then, add the following code to the <code>GameScene</code> class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Updates the top and bottom cards in the discard pile to reflect the state from the Solitaire
</span></span></span><span style=display:flex><span><span style=color:#75715e> * game instance.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>updateCardGameObjectsInDiscardPile</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// update the top card in the discard pile to reflect the card below it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>discardPileCards</span>[<span style=color:#ae81ff>1</span>].<span style=color:#a6e22e>setFrame</span>(<span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>discardPileCards</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>frame</span>).<span style=color:#a6e22e>setVisible</span>(<span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>discardPileCards</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>visible</span>);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// update the bottom card in the discard pile to have the correct value based on the solitaire game state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>discardPileCards</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>setVisible</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// TODO: grab card state from Solitaire instance and update bottom card frame based on state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Checks the tableau pile that the played card came from to see if we now need to flip the next
</span></span></span><span style=display:flex><span><span style=color:#75715e> * card in the stack.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>handleRevealingNewTableauCards</span>(<span style=color:#a6e22e>tableauPileIndex</span>: <span style=color:#66d9ef>number</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// TODO
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Updates each card in the foundation piles to have the latest card frame after a card is dropped in the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * foundation zone. Will make the card visible if an Ace is played.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>updateFoundationPiles</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// TODO
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>In the code above, we attempt to grab the <code>pileIndex</code> field from the card game objects data manager, and if this is found, we call the <code>moveTableauCardToFoundation</code> method on our Solitaire game instance. If the <code>pileIndex</code> is not found, we call the <code>playDiscardPileCardToFoundation</code> method on the Solitaire game instance. In both cases, these methods will return a <code>boolean</code> value indicating if this was a valid move. If the move is not valid, then we will return early from the method and rely on the <code>dragend</code> event listener to place the game object back in the original position.</p><p>If the move is valid, then we call the new methods that we added. For the time being, these methods will do nothing. Finally, if the card was from the <code>tableau</code> card piles, then we call the <code>destroy</code> method on the game object to remove that game object from our game. The reason we are destroying the game object is, in our foundation card piles we have 4 card game objects that are used for displaying the current card, and so we can remove the card game object that was placed up there.</p><p>In the <code>#updateCardGameObjectsInDiscardPile</code> method, this logic is similar to the <code>pointerdown</code> event listener logic that we added to the draw pile. In this case, we are updating the top card to match the bottom card that was below it, and we are doing this by updating the <code>frame</code> and the <code>visibility</code> of the game object. We then update the bottom card to not be visible. For the time being, this will work, but we will need to update this later to match the state of the Solitaire game instance.</p><p>Now, back in the browser if you drag cards from one tableau pile onto the foundation drop zone, those cards will be removed from the game. If you draw cards and add those cards to the foundation pile, eventually the discard pile will appear empty.</p><p><img src=./images/solitaire-phaser-3-tutorial-4-3.gif alt="Move cards to foundation pile"></p><p>So now that we are destroying some of our card game objects, we will need to modify the logic in our <code>dragend</code> event listener to make sure the game object is still active before we attempt to modify the game object. This is needed because once we call <code>destroy</code> on the game objects, Phaser will start to cleanup these objects from our game internally, and if we try to do things like update the texture, or modify the data in the data manager, we will get an error. When the game object is being destroyed, Phaser will update the <code>active</code> property on the game object to be set to <code>false</code>, and so we can check for this value in our event listener. To do this, we can remove the following code from the event listener in the <code>#createDragEndEventListener</code> method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// TODO: check if game object overlaps with foundation
</span></span></span><span style=display:flex><span><span style=color:#75715e>// TODO: check if game object overlaps with tableau
</span></span></span><span style=display:flex><span><span style=color:#75715e>// TODO: check if game object overlaps with with multiple tableau piles and determine were to place game object
</span></span></span><span style=display:flex><span><span style=color:#75715e>// TODO: if game object was not destroyed, still active, we need to update that game objects data to match were the card was placed
</span></span></span></code></pre></div><p>and we can add then wrap the remaining logic in an <code>if</code> statement like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// if game object was not destroyed, still active, we need to update that game objects data to match were the card was placed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>gameObject</span>.<span style=color:#a6e22e>active</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>gameObject</span>.<span style=color:#a6e22e>setPosition</span>(<span style=color:#a6e22e>gameObject</span>.<span style=color:#a6e22e>getData</span>(<span style=color:#e6db74>&#39;x&#39;</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span>, <span style=color:#a6e22e>gameObject</span>.<span style=color:#a6e22e>getData</span>(<span style=color:#e6db74>&#39;y&#39;</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span>);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// reset card game objects alpha since we are done moving the object
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>gameObject</span>.<span style=color:#a6e22e>setAlpha</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// if card is part of the tableau, we need to move all cards that are stacked on top of this card back to the original location as well
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>cardIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>gameObject</span>.<span style=color:#a6e22e>getData</span>(<span style=color:#e6db74>&#39;cardIndex&#39;</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>tableauPileIndex</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>undefined</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>numberOfCardsToMove</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>getNumberOfCardsToMoveAsPartOfStack</span>(<span style=color:#a6e22e>tableauPileIndex</span>, <span style=color:#a6e22e>cardIndex</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>numberOfCardsToMove</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>cardToMove</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>tableauContainers</span>[<span style=color:#a6e22e>tableauPileIndex</span>].<span style=color:#a6e22e>getAt</span>&lt;<span style=color:#f92672>Phaser.GameObjects.Image</span>&gt;(
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cardIndex</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>i</span>,
</span></span><span style=display:flex><span>      );
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>cardToMove</span>.<span style=color:#a6e22e>setPosition</span>(<span style=color:#a6e22e>cardToMove</span>.<span style=color:#a6e22e>getData</span>(<span style=color:#e6db74>&#39;x&#39;</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span>, <span style=color:#a6e22e>cardToMove</span>.<span style=color:#a6e22e>getData</span>(<span style=color:#e6db74>&#39;y&#39;</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The reason we are removing the other <code>TODO</code>s is because we are now handling those checks in the <code>drop</code> event listener.</p><h2 id=adding-cards-to-tableau>Adding Cards To Tableau</h2><p>So now that we have the base logic in place for placing cards on the foundation piles, we need to add similar logic for placing cards on the tableau piles, and we will do this logic in the <code>#handleMoveCardTableau</code> method. For this logic, we first need to check if the card being added to a tableau pile is from the discard pile, or from another tableau pile. Once this is determined, we will check if the card movement was valid, then we will move the card, or cards, to the correct tableau stack. To do this, we will need to add the following logic to the <code>#handleMoveCardTableau</code> method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>isValidMove</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>isCardFromDiscardPile</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// store reference to the original size of the tableau pile so we know were to place game object
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>originalTargetPileSize</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>tableauContainers</span>[<span style=color:#a6e22e>targetTableauPileIndex</span>].<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// check if card is from discard pile or tableau pile based on the pileIndex in the data manager
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tableauPileIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>gameObject</span>.<span style=color:#a6e22e>getData</span>(<span style=color:#e6db74>&#39;pileIndex&#39;</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>undefined</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tableauCardIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>gameObject</span>.<span style=color:#a6e22e>getData</span>(<span style=color:#e6db74>&#39;cardIndex&#39;</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>tableauPileIndex</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>undefined</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>isValidMove</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>solitaire</span>.<span style=color:#a6e22e>playDiscardPileCardToTableau</span>(<span style=color:#a6e22e>targetTableauPileIndex</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>isCardFromDiscardPile</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>isValidMove</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>solitaire</span>.<span style=color:#a6e22e>moveTableauCardsToAnotherTableau</span>(
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>tableauPileIndex</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>tableauCardIndex</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>targetTableauPileIndex</span>,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// if this is not a valid move, we don&#39;t need to update anything on the card(s) since the `dragend` event handler will
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// move the card(s) back to the original location
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>isValidMove</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// add single discard pile card to tableau as a new game object
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>isCardFromDiscardPile</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>card</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>createCard</span>(
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>originalTargetPileSize</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>20</span>,
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>originalTargetPileSize</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>targetTableauPileIndex</span>,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>card</span>.<span style=color:#a6e22e>setFrame</span>(<span style=color:#a6e22e>gameObject</span>.<span style=color:#a6e22e>frame</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>tableauContainers</span>[<span style=color:#a6e22e>targetTableauPileIndex</span>].<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>card</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// update the remaining cards in discard pile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>updateCardGameObjectsInDiscardPile</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// for each card in the current stack that is being moved, we need to remove the card from
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// the existing container and add to the target tableau container
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>numberOfCardsToMove</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>getNumberOfCardsToMoveAsPartOfStack</span>(<span style=color:#a6e22e>tableauPileIndex</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span>, <span style=color:#a6e22e>tableauCardIndex</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>numberOfCardsToMove</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>cardGameObject</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>tableauContainers</span>[<span style=color:#a6e22e>tableauPileIndex</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span>].<span style=color:#a6e22e>getAt</span>&lt;<span style=color:#f92672>Phaser.GameObjects.Image</span>&gt;(<span style=color:#a6e22e>tableauCardIndex</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>tableauContainers</span>[<span style=color:#a6e22e>tableauPileIndex</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span>].<span style=color:#a6e22e>removeAt</span>(<span style=color:#a6e22e>tableauCardIndex</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>tableauContainers</span>[<span style=color:#a6e22e>targetTableauPileIndex</span>].<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>cardGameObject</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// update phaser game object data to match the new values for tableau and card index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>cardIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>originalTargetPileSize</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>i</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cardGameObject</span>.<span style=color:#a6e22e>setData</span>({
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>x</span>: <span style=color:#66d9ef>0</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>y</span>: <span style=color:#66d9ef>cardIndex</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>20</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>cardIndex</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>pileIndex</span>: <span style=color:#66d9ef>targetTableauPileIndex</span>,
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// update depth on container to be the original value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>tableauContainers</span>[<span style=color:#a6e22e>tableauPileIndex</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span>].<span style=color:#a6e22e>setDepth</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// get the cards tableau pile and check to see if the new card at the bottom of the stack should be flipped over
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>this</span>.<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>handleRevealingNewTableauCards</span>(<span style=color:#a6e22e>tableauPileIndex</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>number</span>);
</span></span></code></pre></div><p>In the code above we did logic very similar to what we did in the <code>#handleMoveCardToFoundation</code> method. First, we checked if the card that was played came from the discard pile, or from another tableau pile. Based on this check, we then call the relevant method in our <code>Solitaire</code> class to make sure the move is valid, and if the move is not valid we return early. If the move is valid, then we do the following logic based on were the card, or cards came from:</p><ul><li>If the card came from the discard pile, then we create a brand new Card Image game object and update the frame on this game object to match the card that was played. We then add this card to the target tableau card pile and position the game object to appear as the bottom card on the stack. Finally, we call the method to update our cards in our discard pile to show that we played the last card.</li><li>If the card came from another tableau pile, then the first thing we check to see how many cards are being moved. For each card that is being moved, we grab those Image game objects from the original <code>tableauContainer</code> the card is in and remove that game object from that container. We then add that card to the <code>tableauContainer</code> that is tied to the tableau pile we are moving the card to. Finally, we update the data in the data manager to match the new location for the card, and we call the <code>#handleRevealingNewTableauCards</code> method, which will be responsible for flipping over the next card in a tableau pile if needed.</li></ul><p>Now, back in the browser if you drag cards from one tableau pile onto another tableau pile, those cards will be moved to the other pile. If you draw cards and add those cards to a tableau pile, those cards will show up as new cards on the tableau pile and eventually the discard pile will appear empty.</p><p><img src=./images/solitaire-phaser-3-tutorial-4-4.gif alt="Move cards to tableau pile"></p><p>Now, if you want to test the logic for invalid moves, if you open the <code>Solitaire</code> class, and update all of the methods to return <code>false</code>, if you do the same tests as before, you will see all of the cards will snap back to the original locations.</p><p><img src=./images/solitaire-phaser-3-tutorial-4-5.gif alt="Move cards to invalid locations"></p><h2 id=summary>Summary</h2><p>All right, with those last changes that brings an end to this part of the tutorial. In this part of the tutorial, we continued working on our Solitaire game and we focused on adding logic to move cards between the various piles in our game and we started to stub out the class that will be used for the core Solitaire game logic.</p><p>You can find the completed source code for this article here on GitHub:
<a href=https://github.com/devshareacademy/phaser-3-solitaire-tutorial/tree/moving_cards target=_blank rel=noopener>Part 4 Source Code</a></p><p>If you run into any issues, please reach out via
<a href=https://github.com/devshareacademy/phaser-3-solitaire-tutorial/discussions target=_blank rel=noopener>GitHub Discussions</a>
, or leave a comment down below.</p><p>In part 5 of this series, we work on adding the core game logic to our <code>Solitaire</code> class and connect this logic to our <code>GameScene</code>.</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/html5/ rel=tag>HTML5</a></li><li class=tags__item><a class="tags__link btn" href=/tags/game-development/ rel=tag>Game Development</a></li><li class=tags__item><a class="tags__link btn" href=/tags/typescript/ rel=tag>TypeScript</a></li><li class=tags__item><a class="tags__link btn" href=/tags/tutorial/ rel=tag>Tutorial</a></li><li class=tags__item><a class="tags__link btn" href=/tags/solitaire/ rel=tag>Solitaire</a></li><li class=tags__item><a class="tags__link btn" href=/tags/phaserjs/ rel=tag>PhaserJS</a></li><li class=tags__item><a class="tags__link btn" href=/tags/phaser3/ rel=tag>Phaser3</a></li></ul></div></footer></article></main><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="Scott Westover avatar" src=https://secure.gravatar.com/avatar/d5b6863a31baa2c531949202b1de9c82 class=avatar height=90 width=90></figure><div class=authorbox__header><span class=authorbox__name>About Scott Westover</span></div><div class=authorbox__description>Scott Westover is a Software Developer who loves coding, writing tutorials, participating in game jams, and learning about new technologies. When he is not coding, he is either spending time with his wife and two kids or is reading a great book. Scott is looking to form connections and share his knowledge.</div></div><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/post/2024/08/solitaire-phaser-3-tutorial-3/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>Solitaire HTML5 Game Tutorial With Phaser 3 Part 3: Player Input</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/post/2024/08/solitaire-phaser-3-tutorial-5/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>Solitaire HTML5 Game Tutorial With Phaser 3 Part 5: Core Solitaire Logic</p></a></div></nav><section class=comments><div id=gitment-comments></div></section><script src=https://utteranc.es/client.js repo=scottwestover/scottwestover.dev issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2024 Scott Westover.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>